# 公共基础层 - 卡片渲染系统技术设计

**版本**: 1.0.0  
**更新时间**: 2026-01-31  
**状态**: 正式版

---

## 1. 系统概述

### 1.1 架构定位

卡片渲染系统是公共基础层的核心模块之一，负责将卡片文件（.card、.box）转换为可视化的网页内容。系统采用插件化架构，通过调用基础卡片插件的前端代码和布局插件，生成 iframe 窗口供上层产品使用。

### 1.2 核心原则

1. **插件化渲染**：所有基础卡片和布局都通过插件实现
2. **iframe 隔离**：每个基础卡片渲染为独立 iframe，确保样式和脚本隔离
3. **主题分离**：基础卡片插件不包含样式，通过主题包注入
4. **统一接口**：提供标准化的渲染接口供上层调用

### 1.3 渲染流程概览

```
调用方（Viewer/Editor）
    ↓ （通过路由调用）
CardRenderer / BoxRenderer
    ↓
解析卡片/箱子文件
    ↓
遍历基础卡片列表
    ↓
调用 BaseCardRenderers
    ↓
BaseCardRenderer 调用基础卡片插件前端代码
    ↓
填充配置数据到模板
    ↓
生成 HTML 网页 → 创建 iframe
    ↓
组合所有 iframe + 菜单栏 + 主题背景
    ↓
返回完整的大 iframe 窗口
```

---

## 2. CardRenderer（卡片渲染引擎）

### 2.1 接口定义

```typescript
/**
 * 卡片渲染引擎
 * 负责完整的卡片渲染流程
 */
export interface ICardRenderer {
  /**
   * 渲染卡片
   * @param request 渲染请求
   * @returns 渲染结果（iframe 窗口）
   */
  render(request: CardRenderRequest): Promise<CardRenderResult>;
  
  /**
   * 解析卡片结构（不渲染）
   * @param cardId 卡片 ID 或文件路径
   * @returns 卡片结构信息
   */
  parse(cardId: string): Promise<CardStructure>;
  
  /**
   * 销毁渲染结果
   * @param renderId 渲染 ID
   */
  dispose(renderId: string): void;
}

/**
 * 渲染请求
 */
export interface CardRenderRequest {
  /** 卡片 ID 或文件路径 */
  card_id: string;
  
  /** 目标容器 ID */
  container_id: string;
  
  /** 渲染选项 */
  options?: {
    /** 主题 ID（格式：发行商:主题名） */
    theme_id?: string;
    
    /** 是否启用交互（默认 true） */
    interactive?: boolean;
    
    /** 是否只读模式（默认 true） */
    readonly?: boolean;
    
    /** 渲染质量（默认 'high'） */
    quality?: 'low' | 'medium' | 'high';
    
    /** 是否启用懒加载（默认 true） */
    lazy_load?: boolean;
    
    /** 是否启用虚拟滚动（默认 true） */
    virtual_scroll?: boolean;
  };
}

/**
 * 渲染结果
 */
export interface CardRenderResult {
  /** 渲染 ID */
  render_id: string;
  
  /** 渲染的 iframe 窗口 */
  frame: HTMLIFrameElement;
  
  /** 卡片元数据 */
  metadata: CardMetadata;
  
  /** 渲染时间戳 */
  timestamp: number;
}

/**
 * 卡片结构
 */
export interface CardStructure {
  /** 卡片元数据 */
  metadata: CardMetadata;
  
  /** 基础卡片列表 */
  base_cards: BaseCardInfo[];
  
  /** 主题配置 */
  theme_config?: ThemeConfig;
}
```

### 2.2 实现设计

```typescript
/**
 * 卡片渲染引擎实现
 */
export class CardRenderer implements ICardRenderer {
  private zipProcessor: IZIPProcessor;
  private baseCardRenderers: Map<string, IBaseCardRenderer>;
  private themeEngine: IThemeEngine;
  private iframeWrapper: IFrameWrapper;
  private renderCache: Map<string, CardRenderResult>;
  
  constructor(
    zipProcessor: IZIPProcessor,
    themeEngine: IThemeEngine,
    iframeWrapper: IFrameWrapper
  ) {
    this.zipProcessor = zipProcessor;
    this.themeEngine = themeEngine;
    this.iframeWrapper = iframeWrapper;
    this.baseCardRenderers = new Map();
    this.renderCache = new Map();
    
    this.registerDefaultRenderers();
  }
  
  /**
   * 渲染卡片
   */
  async render(request: CardRenderRequest): Promise<CardRenderResult> {
    // 1. 解析卡片文件
    const structure = await this.parse(request.card_id);
    
    // 2. 创建渲染 ID
    const renderId = this.generateRenderId();
    
    // 3. 渲染所有基础卡片
    const baseCardFrames: HTMLIFrameElement[] = [];
    
    for (const baseCard of structure.base_cards) {
      const frame = await this.renderBaseCard(
        baseCard,
        request.options
      );
      baseCardFrames.push(frame);
    }
    
    // 4. 应用主题
    const themeId = request.options?.theme_id || 
                    structure.theme_config?.theme_id || 
                    'chipshub:default';
    
    const themeFrame = await this.themeEngine.createThemeBackground(
      themeId,
      structure.metadata
    );
    
    // 5. 创建菜单栏
    const menuBar = this.createMenuBar(structure.metadata);
    
    // 6. 组合所有元素到大 iframe
    const masterFrame = await this.createMasterFrame({
      menuBar,
      baseCardFrames,
      themeFrame,
      metadata: structure.metadata
    });
    
    // 7. 嵌入到目标容器
    const container = document.getElementById(request.container_id);
    if (!container) {
      throw new Error(`Container not found: ${request.container_id}`);
    }
    container.appendChild(masterFrame);
    
    // 8. 缓存渲染结果
    const result: CardRenderResult = {
      render_id: renderId,
      frame: masterFrame,
      metadata: structure.metadata,
      timestamp: Date.now()
    };
    
    this.renderCache.set(renderId, result);
    
    return result;
  }
  
  /**
   * 解析卡片文件
   */
  async parse(cardId: string): Promise<CardStructure> {
    // 1. 使用 ZIPProcessor 读取 .card 文件
    const cardData = await this.zipProcessor.extract(cardId);
    
    // 2. 解析 metadata.yaml
    const metadataYaml = cardData.files.find(
      f => f.path === '.card/metadata.yaml'
    );
    const metadata = YAML.parse(metadataYaml.content);
    
    // 3. 解析 structure.yaml
    const structureYaml = cardData.files.find(
      f => f.path === '.card/structure.yaml'
    );
    const structureData = YAML.parse(structureYaml.content);
    
    // 4. 读取基础卡片配置
    const baseCards: BaseCardInfo[] = [];
    
    for (const cardInfo of structureData.base_cards) {
      const configPath = `content/${cardInfo.id}.yaml`;
      const configFile = cardData.files.find(f => f.path === configPath);
      const config = YAML.parse(configFile.content);
      
      baseCards.push({
        id: cardInfo.id,
        type: cardInfo.type,
        config: config,
        order: cardInfo.order
      });
    }
    
    return {
      metadata,
      base_cards: baseCards,
      theme_config: structureData.theme_config
    };
  }
  
  /**
   * 渲染单个基础卡片
   */
  private async renderBaseCard(
    baseCard: BaseCardInfo,
    options?: CardRenderRequest['options']
  ): Promise<HTMLIFrameElement> {
    // 1. 获取对应的 BaseCardRenderer
    const renderer = this.baseCardRenderers.get(baseCard.type);
    if (!renderer) {
      throw new Error(`No renderer for card type: ${baseCard.type}`);
    }
    
    // 2. 调用渲染器
    const html = await renderer.render(baseCard.config, options);
    
    // 3. 创建 iframe 并加载 HTML
    const iframe = await this.iframeWrapper.create({
      html: html,
      transparent: true,  // 背景透明
      sandbox: ['allow-scripts', 'allow-same-origin'],
      width: '100%',
      height: 'auto'
    });
    
    return iframe;
  }
  
  /**
   * 创建大 iframe 窗口
   */
  private async createMasterFrame(params: {
    menuBar: HTMLElement;
    baseCardFrames: HTMLIFrameElement[];
    themeFrame: HTMLIFrameElement;
    metadata: CardMetadata;
  }): Promise<HTMLIFrameElement> {
    // 组合所有元素到一个 HTML 文档
    const html = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${params.metadata.name}</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      position: relative;
    }
    
    #theme-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }
    
    #content-wrapper {
      position: relative;
      z-index: 1;
    }
    
    #menu-bar {
      position: sticky;
      top: 0;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      padding: 12px 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      z-index: 100;
    }
    
    #base-cards-container {
      display: flex;
      flex-direction: column;
      gap: 0;
    }
    
    .base-card-frame {
      width: 100%;
      border: none;
      background: transparent;
    }
  </style>
</head>
<body>
  <!-- 主题背景 -->
  <div id="theme-background">
    <!-- 主题 iframe 嵌入这里 -->
  </div>
  
  <!-- 内容层 -->
  <div id="content-wrapper">
    <!-- 菜单栏 -->
    <div id="menu-bar">
      ${params.menuBar.outerHTML}
    </div>
    
    <!-- 基础卡片容器 -->
    <div id="base-cards-container">
      ${params.baseCardFrames.map((frame, index) => `
        <div class="base-card-frame" data-card-index="${index}">
          ${frame.outerHTML}
        </div>
      `).join('')}
    </div>
  </div>
</body>
</html>
    `;
    
    // 创建大 iframe
    const masterFrame = await this.iframeWrapper.create({
      html: html,
      transparent: false,
      width: '100%',
      height: '100%',
      sandbox: ['allow-scripts', 'allow-same-origin', 'allow-popups']
    });
    
    return masterFrame;
  }
  
  /**
   * 创建菜单栏
   */
  private createMenuBar(metadata: CardMetadata): HTMLElement {
    const menuBar = document.createElement('div');
    menuBar.className = 'card-menu-bar';
    menuBar.innerHTML = `
      <div class="card-title">${metadata.name}</div>
      <div class="card-actions">
        <button class="btn-share">分享</button>
        <button class="btn-export">导出</button>
        <button class="btn-more">更多</button>
      </div>
    `;
    return menuBar;
  }
  
  /**
   * 注册默认的基础卡片渲染器
   */
  private registerDefaultRenderers(): void {
    // 注册所有 26 种基础卡片渲染器
    this.baseCardRenderers.set('richtext', new RichTextCardRenderer());
    this.baseCardRenderers.set('markdown', new MarkdownCardRenderer());
    this.baseCardRenderers.set('image', new ImageCardRenderer());
    this.baseCardRenderers.set('video', new VideoCardRenderer());
    this.baseCardRenderers.set('audio', new AudioCardRenderer());
    // ... 其他 21 种
  }
  
  /**
   * 生成渲染 ID
   */
  private generateRenderId(): string {
    return `render_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  
  /**
   * 销毁渲染结果
   */
  dispose(renderId: string): void {
    const result = this.renderCache.get(renderId);
    if (result) {
      result.frame.remove();
      this.renderCache.delete(renderId);
    }
  }
}
```

---

## 3. BaseCardRenderers（基础卡片渲染器）

### 3.1 通用接口

```typescript
/**
 * 基础卡片渲染器接口
 * 所有 26 种基础卡片渲染器都实现此接口
 */
export interface IBaseCardRenderer {
  /**
   * 渲染基础卡片
   * @param config 卡片配置（从 content/ID.yaml 读取）
   * @param options 渲染选项
   * @returns 生成的 HTML 字符串
   */
  render(config: BaseCardConfig, options?: RenderOptions): Promise<string>;
  
  /**
   * 获取渲染器支持的卡片类型
   */
  getSupportedType(): string;
}

/**
 * 基础卡片配置（通用结构）
 */
export interface BaseCardConfig {
  /** 卡片 ID */
  id: string;
  
  /** 卡片类型 */
  type: string;
  
  /** 主题配置（可选，原子级） */
  theme?: string;
  
  /** 具体内容配置（由各渲染器定义） */
  content: any;
}
```

### 3.2 示例：视频卡片渲染器

```typescript
/**
 * 视频卡片配置
 */
export interface VideoCardConfig extends BaseCardConfig {
  content: {
    /** 视频路径 */
    video_path: string;
    
    /** 封面图片路径 */
    poster_path?: string;
    
    /** 字幕列表 */
    subtitles?: Array<{
      path: string;
      language: string;
      label: string;
    }>;
    
    /** 播放参数 */
    playback?: {
      autoplay?: boolean;
      loop?: boolean;
      muted?: boolean;
      controls?: boolean;
      preload?: 'auto' | 'metadata' | 'none';
    };
  };
}

/**
 * 视频卡片渲染器
 * 负责调用视频卡片插件的前端代码并填充数据
 */
export class VideoCardRenderer implements IBaseCardRenderer {
  private videoPlayerModule: IVideoPlayer;
  
  constructor(videoPlayerModule: IVideoPlayer) {
    this.videoPlayerModule = videoPlayerModule;
  }
  
  getSupportedType(): string {
    return 'video';
  }
  
  async render(
    config: VideoCardConfig, 
    options?: RenderOptions
  ): Promise<string> {
    // 1. 加载视频卡片插件的前端代码
    const pluginCode = await this.loadPluginFrontendCode('video-card');
    
    // 2. 准备数据
    const data = {
      videoPath: this.resolveResourcePath(config.content.video_path),
      posterPath: this.resolveResourcePath(config.content.poster_path),
      subtitles: config.content.subtitles?.map(sub => ({
        ...sub,
        path: this.resolveResourcePath(sub.path)
      })),
      playback: config.content.playback || {}
    };
    
    // 3. 填充数据到插件模板
    const html = pluginCode.renderTemplate(data);
    
    // 4. 添加主题接口点
    const htmlWithTheme = this.addThemeInterfacePoints(html, config.theme);
    
    return htmlWithTheme;
  }
  
  /**
   * 加载插件前端代码
   */
  private async loadPluginFrontendCode(pluginId: string): Promise<PluginFrontendCode> {
    // 从插件系统加载指定插件的前端代码
    // 这里简化处理，实际应该通过插件管理器加载
    return {
      renderTemplate: (data: any) => {
        // 插件的渲染函数，返回 HTML
        return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <style>
    /* 插件定义的结构样式（布局、不含颜色） */
    .video-card {
      display: flex;
      flex-direction: column;
      width: 100%;
    }
    
    .video-player-container {
      position: relative;
      width: 100%;
      aspect-ratio: 16 / 9;
    }
    
    .video-info {
      padding: var(--spacing-md, 16px);
    }
    
    /* 主题接口点 - 通过 CSS 变量和类名暴露 */
    .video-card {
      background: var(--card-background, #fff);
      color: var(--card-text, #000);
      border-radius: var(--card-border-radius, 8px);
    }
  </style>
</head>
<body>
  <div class="video-card theme-target">
    <div class="video-player-container">
      <!-- 这里会由 VideoPlayer 模块渲染 -->
      <video-player
        src="${data.videoPath}"
        poster="${data.posterPath}"
        controls="${data.playback.controls ?? true}"
        autoplay="${data.playback.autoplay ?? false}">
        ${data.subtitles?.map(sub => `
          <track kind="subtitles" src="${sub.path}" 
                 srclang="${sub.language}" label="${sub.label}">
        `).join('') || ''}
      </video-player>
    </div>
  </div>
  
  <script>
    // 插件的交互逻辑
    document.addEventListener('DOMContentLoaded', () => {
      // 初始化视频播放器（调用 VideoPlayer 模块）
      const playerElement = document.querySelector('video-player');
      // ... 初始化代码
    });
  </script>
</body>
</html>
        `;
      }
    };
  }
  
  /**
   * 解析资源路径
   */
  private resolveResourcePath(path?: string): string {
    if (!path) return '';
    
    // 如果是相对路径，转换为绝对路径
    if (!path.startsWith('http') && !path.startsWith('/')) {
      return `chips://card/current/${path}`;
    }
    
    return path;
  }
  
  /**
   * 添加主题接口点
   */
  private addThemeInterfacePoints(html: string, themeId?: string): string {
    // 如果指定了主题，添加主题类名
    if (themeId) {
      html = html.replace(
        'class="video-card theme-target"',
        `class="video-card theme-target theme-${themeId}"`
      );
    }
    
    return html;
  }
}
```

---

## 4. BoxRenderer（箱子渲染引擎）

### 4.1 接口定义

```typescript
/**
 * 箱子渲染引擎接口
 */
export interface IBoxRenderer {
  /**
   * 渲染箱子
   * @param request 渲染请求
   * @returns 渲染结果（iframe 窗口）
   */
  render(request: BoxRenderRequest): Promise<BoxRenderResult>;
  
  /**
   * 解析箱子结构（不渲染）
   * @param boxId 箱子 ID 或文件路径
   * @returns 箱子结构信息
   */
  parse(boxId: string): Promise<BoxStructure>;
}

/**
 * 箱子渲染请求
 */
export interface BoxRenderRequest {
  /** 箱子 ID 或文件路径 */
  box_id: string;
  
  /** 目标容器 ID */
  container_id: string;
  
  /** 渲染选项 */
  options?: {
    /** 主题 ID */
    theme_id?: string;
    
    /** 是否启用交互（默认 true） */
    interactive?: boolean;
    
    /** 是否加载外部引用的卡片（默认 false） */
    load_external?: boolean;
    
    /** 自定义布局配置（覆盖箱子默认配置） */
    layout_config?: any;
  };
}

/**
 * 箱子结构
 */
export interface BoxStructure {
  /** 箱子元数据 */
  metadata: BoxMetadata;
  
  /** 卡片列表 */
  cards: CardSummary[];
  
  /** 布局配置 */
  layout_config: LayoutConfig;
}
```

### 4.2 实现设计

```typescript
/**
 * 箱子渲染引擎实现
 */
export class BoxRenderer implements IBoxRenderer {
  private zipProcessor: IZIPProcessor;
  private layoutPluginManager: ILayoutPluginManager;
  private themeEngine: IThemeEngine;
  private iframeWrapper: IFrameWrapper;
  
  async render(request: BoxRenderRequest): Promise<BoxRenderResult> {
    // 1. 解析箱子文件
    const structure = await this.parse(request.box_id);
    
    // 2. 加载布局插件
    const layoutType = structure.layout_config.layout_type;
    const layoutPlugin = await this.layoutPluginManager.load(layoutType);
    
    // 3. 调用布局插件生成展示网页
    const html = await layoutPlugin.render({
      cards: structure.cards,
      config: request.options?.layout_config || structure.layout_config
    });
    
    // 4. 应用主题
    const themeId = request.options?.theme_id || 'chipshub:default';
    const htmlWithTheme = await this.themeEngine.applyToHTML(html, themeId);
    
    // 5. 创建 iframe
    const frame = await this.iframeWrapper.create({
      html: htmlWithTheme,
      transparent: false,
      width: '100%',
      height: '100%',
      sandbox: ['allow-scripts', 'allow-same-origin']
    });
    
    // 6. 设置交互事件监听
    if (request.options?.interactive !== false) {
      this.setupBoxInteraction(frame);
    }
    
    // 7. 嵌入到容器
    const container = document.getElementById(request.container_id);
    if (container) {
      container.appendChild(frame);
    }
    
    return {
      render_id: this.generateRenderId(),
      frame: frame,
      metadata: structure.metadata,
      timestamp: Date.now()
    };
  }
  
  async parse(boxId: string): Promise<BoxStructure> {
    // 解析箱子文件（类似 CardRenderer.parse）
    // ...
  }
  
  /**
   * 设置箱子交互
   */
  private setupBoxInteraction(frame: HTMLIFrameElement): void {
    // 监听 iframe 内的卡片点击事件
    frame.contentWindow?.addEventListener('message', (event) => {
      if (event.data.type === 'cardClick') {
        // 触发自定义事件，通知调用方
        const customEvent = new CustomEvent('boxCardClick', {
          detail: { cardId: event.data.cardId }
        });
        frame.dispatchEvent(customEvent);
      }
    });
  }
}
```

---

## 5. ThemeEngine（主题引擎）

### 5.1 接口定义

```typescript
/**
 * 主题引擎接口
 */
export interface IThemeEngine {
  /**
   * 加载主题包
   * @param themeId 主题 ID（格式：发行商:主题名）
   */
  loadTheme(themeId: string): Promise<Theme>;
  
  /**
   * 应用主题到 HTML
   * @param html HTML 字符串
   * @param themeId 主题 ID
   * @returns 应用主题后的 HTML
   */
  applyToHTML(html: string, themeId: string): Promise<string>;
  
  /**
   * 创建主题背景网页
   * @param themeId 主题 ID
   * @param metadata 卡片元数据
   * @returns 主题背景 iframe
   */
  createThemeBackground(themeId: string, metadata: CardMetadata): Promise<HTMLIFrameElement>;
  
  /**
   * 处理主题层级
   * @param config 主题配置（组件/卡片/应用/全局）
   * @returns 最终使用的主题 ID
   */
  resolveTheme(config: ThemeHierarchyConfig): string;
}
```

### 5.2 实现要点

- 解析主题包结构（CSS 文件、JS 文件、图片资源）
- 提取对应组件类型的样式代码
- 注入 CSS 变量和样式类到 HTML
- 处理主题层级（组件 > 卡片 > 应用 > 全局）
- 维护主题缓存，避免重复加载

---

## 6. 性能优化

### 6.1 渲染优化

1. **懒加载**：基础卡片进入视口才渲染
2. **虚拟滚动**：大型卡片使用虚拟滚动
3. **增量渲染**：分批渲染基础卡片
4. **渲染缓存**：缓存已渲染的结果

### 6.2 资源优化

1. **资源预加载**：预测性加载即将显示的资源
2. **懒加载图片/视频**：使用 Intersection Observer
3. **网络缓存**：缓存已下载的资源
4. **资源压缩**：优化图片和视频大小

### 6.3 iframe 优化

1. **iframe 池**：重用 iframe 实例
2. **沙箱控制**：合理设置 sandbox 属性
3. **通信优化**：批量处理消息
4. **内存管理**：及时销毁不用的 iframe

---

## 7. 安全性设计

### 7.1 iframe 沙箱

- 限制 iframe 的权限（sandbox 属性）
- 禁止不必要的脚本执行
- 限制网络请求范围

### 7.2 内容安全

- 验证卡片文件签名
- 过滤恶意脚本和样式
- 限制资源加载来源

### 7.3 权限控制

- 检查调用方权限
- 限制敏感操作
- 审计关键操作

---

## 8. 总结

卡片渲染系统通过以下设计实现高质量的卡片渲染：

1. **插件化架构**：基础卡片和布局通过插件实现，易于扩展
2. **iframe 隔离**：确保样式和脚本不冲突
3. **主题分离**：插件只定义结构，样式由主题注入
4. **统一接口**：提供标准化的渲染接口
5. **性能优化**：懒加载、虚拟滚动、缓存等多种优化策略

这套系统为 Chips 生态提供了强大、灵活、高性能的卡片渲染能力。

---

**文档维护者**：Chips 生态团队  
**审核状态**：✅ 已审核  
**相关文档**：
- [卡片渲染模块需求](../需求文档/03-卡片渲染模块需求.md)
- [卡片渲染机制详解](../../生态设计原稿（一切标准）/33-卡片渲染机制详解.md)
- [公共基础层设计](../../生态设计原稿（一切标准）/32-公共基础层设计.md)
