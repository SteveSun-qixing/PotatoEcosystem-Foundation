# 运行时管理器 - 技术文档

## 架构设计

### 整体架构

运行时管理器采用分层模块化架构。最底层是模块注册表,存储所有模块的元数据。中间层是生命周期管理器,负责模块的加载、初始化、运行控制。上层是服务接口层,对外提供模块管理服务。

还包含几个辅助组件。依赖解析器分析模块依赖关系,生成加载顺序。资源监控器跟踪模块资源使用情况。异常处理器捕获和处理模块异常。热更新管理器负责模块的热更新。

各个组件松耦合,通过接口交互。生命周期管理器调用依赖解析器获取加载顺序,调用资源监控器记录资源使用,调用异常处理器处理错误。

### 模块注册表

模块注册表是一个内存数据结构,存储所有模块的元数据。每个模块有唯一的标识符,通常是模块名称加版本号。元数据包括模块的基本信息、入口文件路径、依赖列表、配置Schema等。

注册表在管理器启动时从持久化存储加载。支持多种存储方式,可以是JSON文件、YAML文件,也可以是数据库。注册表更新后自动持久化,确保数据不丢失。

注册表提供高效的查询接口。使用哈希表索引,根据模块标识快速查找模块。维护多个索引,支持按类型、按名称、按标签等不同维度查询。

### 依赖关系图

依赖解析器构建模块依赖关系图,图的节点是模块,边是依赖关系。依赖关系是有向的,从依赖者指向被依赖者。

图构建完成后,执行拓扑排序,得到模块的加载顺序。拓扑排序确保被依赖的模块先加载,依赖者后加载。如果图中有环,说明存在循环依赖,拓扑排序失败,报错并拒绝加载。

依赖关系图支持增量更新。当新模块注册或模块卸载时,不需要重建整个图,只更新相关部分。这提高了效率,特别是模块数量多的时候。

### 生命周期状态机

每个模块的生命周期用状态机表示。状态包括未加载、已加载、已初始化、已启动、运行中、已暂停、已停止、已卸载等。状态之间的转换有明确的规则,只能按照规定的路径转换。

状态转换由生命周期管理器控制。当需要加载模块时,状态从未加载转换到已加载。当需要初始化时,状态从已加载转换到已初始化。每次状态转换都调用模块的对应生命周期方法。

状态机还记录状态转换的历史,用于调试和监控。可以查看模块经历了哪些状态,每个状态停留了多长时间,哪次转换失败了。

### 模块加载器

模块加载器负责将模块代码加载到内存。根据模块的入口文件路径,使用动态加载机制加载模块。支持多种模块格式,包括CommonJS、ES Module、UMD等。

加载器实现模块缓存,已加载的模块缓存起来,避免重复加载。缓存的键是模块的绝对路径,值是模块对象。清除缓存时,模块会被重新加载,实现热更新。

加载器支持沙箱隔离,每个模块在独立的上下文中加载,模块之间不会相互污染。模块只能访问显式导出的接口,不能访问其他模块的内部变量。

## 接口定义

### 模块注册

模块注册接口用于向注册表添加新模块。接口接收模块的元数据,包括标识、名称、版本、入口文件、依赖等。验证元数据的完整性和正确性,验证通过后添加到注册表。

注册接口是幂等的,重复注册同一模块会更新元数据,不会重复添加。这方便模块更新,只需要重新注册即可。

### 模块加载

模块加载接口根据模块标识加载模块。接口先检查模块是否已加载,如果已加载直接返回。如果未加载,查询注册表获取模块信息,解析依赖,按顺序加载依赖和模块本身。

加载接口支持同步和异步两种模式。同步模式阻塞等待加载完成,异步模式立即返回Promise,加载完成后Promise resolve。

加载接口还支持批量加载,传入多个模块标识,并行加载所有模块。这比逐个加载更高效,减少总的加载时间。

### 模块初始化

模块初始化接口调用模块的初始化函数,传入配置参数。模块在初始化函数中创建必要的对象,建立连接,准备运行环境。

初始化可能是耗时操作,接口采用异步模式。初始化完成后,模块状态从已加载转换为已初始化,可以启动服务。

### 模块启动和停止

模块启动接口调用模块的启动函数,模块开始对外提供服务。启动后模块状态变为运行中,可以处理请求。

模块停止接口调用模块的停止函数,模块停止接收新请求,处理完现有请求后清理资源。停止后模块状态变为已停止,可以卸载或重新启动。

启动和停止要优雅,不能强制中断。给模块足够的时间完成清理工作,保存必要的状态。

### 模块卸载

模块卸载接口将模块从内存中移除。先停止模块,然后调用模块的卸载函数,最后从加载器缓存中删除。卸载后模块状态变为已卸载,释放所有资源。

卸载接口要处理依赖关系。不能卸载正在被其他模块依赖的模块,必须先卸载依赖者,再卸载被依赖者。

### 状态查询

状态查询接口返回模块的当前状态。可以查询单个模块的状态,也可以查询所有模块的状态列表。状态信息包括状态名称、进入该状态的时间、状态持续时长等。

### 事件订阅

事件订阅接口用于订阅模块的生命周期事件。订阅者注册回调函数,当事件发生时,回调函数被调用。事件包括模块已加载、已初始化、已启动、已停止、已卸载、发生错误等。

事件通过微内核的事件总线分发,确保所有订阅者都能收到事件。

## 使用方式

### 管理器初始化

应用启动时,运行时管理器首先初始化。加载模块注册表,从配置文件读取所有模块的元数据。构建依赖关系图,准备好模块加载所需的数据结构。

然后加载核心模块,这些模块是必需的,应用启动时就要加载。核心模块加载完成后,管理器进入就绪状态,可以接受模块加载请求。

### 按需加载模块

当上层功能需要使用某个基础层模块时,通过微内核向运行时管理器发送模块加载请求。管理器检查模块是否已加载,如果已加载直接返回模块引用。

如果模块未加载,管理器查询注册表,获取模块信息。解析模块依赖,确定加载顺序。按顺序加载依赖项,最后加载模块本身。加载完成后,初始化模块,启动服务,返回模块引用。

整个过程对上层透明,上层不需要知道模块是新加载的还是已经存在的,只需要调用模块的功能接口。

### 模块热更新

检测到模块有新版本时,运行时管理器执行热更新流程。首先加载新版本模块,但不启动,只是加载到内存中。验证新版本模块的正确性,检查接口是否兼容。

然后通知旧版本模块准备更新,旧版本模块保存当前状态,停止接收新请求,处理完现有请求。状态保存完成后,启动新版本模块,将旧版本的状态迁移到新版本。

新版本模块启动后,更新路由表,将请求路由到新版本。最后卸载旧版本模块,释放资源。整个过程中,服务不中断,用户感知不到更新。

### 异常恢复

模块运行时抛出未捕获异常时,异常处理器捕获异常,记录错误日志。判断异常的严重程度,如果是可恢复的错误,尝试恢复模块。如果是严重错误导致模块崩溃,标记模块为不可用状态。

尝试重启崩溃的模块,重新加载、初始化、启动。如果重启成功,恢复服务,通知上层模块已恢复。如果重启失败,启用降级方案,使用备用模块或降级功能。

### 资源监控

资源监控器定期采集模块的资源使用数据。采集内存占用,通过进程内存统计获取。采集CPU使用率,通过进程CPU时间计算。采集磁盘IO和网络流量,通过系统API获取。

采集到的数据存储在时间序列数据库中,保留一定时间窗口的历史数据。提供查询接口,上层可以查询模块的资源使用情况,生成监控图表。

当资源使用超过阈值时,触发告警。告警信息包含模块标识、资源类型、当前值、阈值等。告警通过事件总线发送,管理员可以及时响应。

## 技术细节

### 循环依赖检测

依赖解析器使用深度优先搜索检测循环依赖。从每个模块开始,沿着依赖边遍历图。如果在遍历过程中再次访问到起始模块,说明存在环,即循环依赖。

检测到循环依赖后,记录环的路径,报错并给出详细信息。告诉开发者哪些模块形成了循环依赖,帮助定位问题。

### 模块沙箱

模块加载在独立的沙箱环境中,使用JavaScript的模块系统提供的隔离机制。每个模块有独立的作用域,模块内的变量不会泄露到全局。

模块只能访问显式导入的其他模块,不能访问未导入的模块。这防止模块之间的意外耦合,提高代码可维护性。

### 状态持久化

模块状态持久化使用序列化机制。模块将状态对象序列化为JSON或其他格式,保存到文件或数据库。下次启动时,反序列化加载状态,恢复到之前的运行状态。

状态持久化要处理不可序列化的对象,比如函数、连接对象等。模块提供状态导出和导入接口,自定义序列化逻辑。

### 性能优化

使用模块预加载优化启动时间。分析历史使用数据,识别常用模块,应用启动时在后台预加载这些模块。当真正需要时,模块已经加载完成,立即可用。

使用并行加载优化加载速度。分析依赖关系,识别可以并行加载的模块,启动多个加载任务同时执行。比如两个没有依赖关系的模块可以并行加载。

使用懒初始化减少内存占用。模块加载后不立即初始化,只在第一次使用时初始化。这样不常用的模块不会占用内存。
